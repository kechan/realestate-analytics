# realestate_analytics/utils/archive.py
"""
Archive reader for month-end listing snapshot data.
"""

import pandas as pd
import json
import calendar
import re
from pathlib import Path
from typing import Union


class MonthEndListingSnapshotArchiveReader:
  """
  Reader for month-end listing snapshot archive files.
  
  This class loads archived current listing counts that represent end-of-month
  snapshots of listing inventory by geographic area and property type, as 
  generated by the AbsorptionRateProcessor.
  
  Args:
    archive_dir: Path to the archive directory containing current_listing_counts files
    
  Example:
    >>> reader = MonthEndListingSnapshotArchiveReader("/path/to/archive")
    >>> df = reader.read()
    >>> print(f"Loaded {len(df)} records")
  """
  
  def __init__(self, archive_dir: Union[str, Path]):
    self.archive_dir = Path(archive_dir)
    if not self.archive_dir.exists():
      raise ValueError(f"Archive directory does not exist: {self.archive_dir}")
  
  def read(self) -> pd.DataFrame:
    """
    Read and load all current listing counts from the archive.
    
    Returns:
      DataFrame with columns [year-month, geog_id, propertyType, current_count]
      where year-month is converted to end-of-month datetime
    """
    df = self._load_current_listing_counts()
    if not df.empty:
      self._convert_yearmonth_to_datetime(df)
    return df
  
  def _load_current_listing_counts(self) -> pd.DataFrame:
    """Load current listing counts files from archive directory."""
    df_files = list(self.archive_dir.glob("current_listing_counts_*_df.txt"))
    print(f"Found {len(df_files)} DataFrame files")
    
    if not df_files:
      return pd.DataFrame(columns=['year-month', 'geog_id', 'propertyType', 'current_count'])
    
    all_data = []
    pattern = r"current_listing_counts_(\d{4}-\d{2})_(\d{8})_df\.txt"
    
    for df_file in df_files:
      match = re.search(pattern, df_file.name)
      if not match:
        continue
        
      year_month, timestamp = match.groups()
      
      try:
        # Load dtypes if available
        dtypes_file = self.archive_dir / f"current_listing_counts_{year_month}_{timestamp}_dtypes.json"
        dtypes = None
        if dtypes_file.exists():
          with open(dtypes_file, 'r') as f:
            dtypes = json.load(f)
        
        df = pd.read_csv(df_file, sep='\t', dtype=dtypes)
        df['year-month'] = year_month
        
        if 'current_count' in df.columns:
          df = df[['year-month', 'geog_id', 'propertyType', 'current_count']]
          all_data.append(df)
          print(f"Loaded {len(df)} records from {year_month}")
          
      except Exception as e:
        print(f"Error processing {df_file.name}: {e}")
    
    if not all_data:
      return pd.DataFrame(columns=['year-month', 'geog_id', 'propertyType', 'current_count'])
    
    result_df = pd.concat(all_data, ignore_index=True)
    result_df = result_df.sort_values(['year-month', 'geog_id', 'propertyType']).reset_index(drop=True)
    
    print(f"Successfully loaded {len(result_df)} total records from {len(all_data)} files")
    return result_df
  
  def _convert_yearmonth_to_datetime(self, df: pd.DataFrame) -> None:
    """Convert year-month column to end-of-month datetime inplace."""
    def get_month_end(year_month_str: str) -> pd.Timestamp:
      year, month = map(int, year_month_str.split('-'))
      last_day = calendar.monthrange(year, month)[1] 
      return pd.to_datetime(f"{year}-{month:02d}-{last_day:02d}")
    
    df['year-month'] = df['year-month'].apply(get_month_end)
    print(f"Converted to end-of-month datetime. Range: {df['year-month'].min()} to {df['year-month'].max()}")

# Example usage:
# reader = MonthEndListingSnapshotArchiveReader("/path/to/archive")
# df = reader.read()